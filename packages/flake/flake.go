package flake

import (
	"bytes"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/vic/ntv/packages/nix"
	"github.com/vic/ntv/packages/search"
)

type Follow struct {
	Input  string `json:"input"`
	Follow string `json:"follow"`
}

type Input struct {
	Name    string   `json:"name"`
	Url     string   `json:"url"`
	Flake   bool     `json:"flake"`
	Follows []Follow `json:"follows"`
}

type Flake struct {
	Inputs  []Input  `json:"inputs"`
	MkFlake string   `json:"mkFlake"`
	Systems string   `json:"systems"`
	Imports []string `json:"imports"`
}

type Tool struct {
	Spec        string `json:"spec"`
	Name        string `json:"name"`
	Version     string `json:"version"`
	Installable string `json:"installable"`
}

type Context struct {
	Tools map[string]Tool `json:"tools"`
	Flake Flake           `json:"flake"`
}

func New() *Context {
	return &Context{
		Tools: map[string]Tool{},
		Flake: Flake{
			Imports: []string{},
			Inputs: []Input{
				{
					Name:  "nixpkgs",
					Url:   "nixpkgs",
					Flake: true,
				},
				{
					Name:  "ntv",
					Url:   "github:vic/ntv",
					Flake: true,
					Follows: []Follow{{
						Input:  "nixpkgs",
						Follow: "nixpkgs",
					}},
				},
			},
			MkFlake: "inputs.ntv.inputs.flake-parts.lib.mkFlake",
			Systems: "import inputs.ntv.inputs.systems",
		},
	}
}

func (f *Flake) OverrideInput(name, url string) {
	for i, in := range f.Inputs {
		if in.Name == name {
			f.Inputs[i].Url = url
		}
	}
}

func (f *Flake) AddInput(name, url string, flake bool, follows []Follow) {
	f.Inputs = append(f.Inputs, Input{
		Name:    name,
		Url:     url,
		Flake:   flake,
		Follows: follows,
	})
}

func (f *Flake) AddFollow(name, input, follow string) {
	for i, in := range f.Inputs {
		if in.Name == name {
			f.Inputs[i].Follows = append(f.Inputs[i].Follows, Follow{
				Input:  input,
				Follow: follow,
			})
		}
	}
}

func (f *Flake) AddImport(importPath string) {
	f.Imports = append(f.Imports, importPath)
}

func (c *Context) AddTool(r *search.PackageSearchResult) {

	c.Tools[r.Selected.Name] = Tool{
		Spec:        *r.FromSearch.Spec,
		Name:        r.Selected.Name,
		Version:     r.Selected.Version,
		Installable: r.Installable(),
	}

	if r.FromSearch.VersionsBackend.CurrentNixpkgs == nil {
		c.Flake.AddInput(r.Selected.Name, r.FlakeUrl(), true, []Follow{})
	}
}

func unpackArray[S ~[]E, E any](s S) []any {
	r := make([]any, len(s))
	for i, e := range s {
		r[i] = e
	}
	return r
}

func (c *Context) Render() (string, error) {
	jsonBytes, err := json.Marshal(c)
	if err != nil {
		return "", err
	}
	nixCode, err := nix.JsonToNix(string(jsonBytes))
	if err != nil {
		return "", err
	}

	buff := bytes.Buffer{}
	w := func(i int, s string, x ...string) {
		if len(x) == 0 {
			buff.WriteString((strings.Repeat("  ", i)) + s + "\n")
		} else {
			buff.WriteString((strings.Repeat("  ", i)) + fmt.Sprintf(s, unpackArray(x)...) + "\n")
		}
	}
	w(0, "{")
	w(1, "# This file was generated by ntv.")
	w(1, "# Edit via the ntv command line.")
	for _, input := range c.Flake.Inputs {
		w(1, "inputs.\"%s\".url = \"%s\";", input.Name, input.Url)
		if !input.Flake {
			w(1, "inputs.\"%s\".flake = false;", input.Name)
		}
		for _, follow := range input.Follows {
			w(1, "inputs.\"%s\".inputs.\"%s\".follows = \"%s\";", input.Name, follow.Input, follow.Follow)
		}
	}
	w(1, "outputs = inputs: let")
	w(2, "ntv = %s;", nixCode)
	w(2, "systems = %s;", c.Flake.Systems)
	w(2, "mkFlake = %s;", c.Flake.MkFlake)
	w(2, "flakeModule = if builtins.pathExists ./flakeModule.nix then ./flakeModule.nix else {};")
	w(1, "in mkFlake { inherit inputs; } {")
	w(2, "inherit systems ntv;")
	w(2, "imports = [")
	w(3, "flakeModule")
	w(3, "inputs.ntv.flakeModules.default")
	for _, importPath := range c.Flake.Imports {
		w(3, "%s", importPath)
	}
	w(2, "];")
	w(1, "};")
	w(0, "}")
	return nix.NixfmtCode(buff.String())
}
